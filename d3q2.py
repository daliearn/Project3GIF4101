{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# -*- coding: utf-8 -*-\n",
    "###############################################################################\n",
    "# Apprentissage et reconnaissance\n",
    "# GIF-4101 / GIF-7005, Automne 2018\n",
    "# Devoir 3, Question 2\n",
    "#\n",
    "###############################################################################\n",
    "############################## INSTRUCTIONS ###################################\n",
    "###############################################################################\n",
    "#\n",
    "# - RepÃ©rez les commentaires commenÃ§ant par TODO : ils indiquent une tÃ¢che que\n",
    "#       vous devez effectuer.\n",
    "# - Vous ne pouvez PAS changer la structure du code, importer d'autres\n",
    "#       modules / sous-modules, ou ajouter d'autres fichiers Python\n",
    "# - Ne touchez pas aux variables, TMAX*, ERRMAX* et _times, Ã  la fonction\n",
    "#       checkTime, ni aux conditions vÃ©rifiant le bon fonctionnement de votre \n",
    "#       code. Ces structures vous permettent de savoir rapidement si vous ne \n",
    "#       respectez pas les requis minimum pour une question en particulier. \n",
    "#       Toute sous-question n'atteignant pas ces minimums se verra attribuer \n",
    "#       la note de zÃ©ro (0) pour la partie implÃ©mentation!\n",
    "#\n",
    "###############################################################################\n",
    "\n",
    "import itertools\n",
    "import time\n",
    "import numpy\n",
    "import warnings\n",
    "from io import BytesIO\n",
    "from http.client import HTTPConnection\n",
    "\n",
    "from sklearn.model_selection import KFold, train_test_split\n",
    "from sklearn.neighbors import KNeighborsClassifier\n",
    "from sklearn.neural_network import MLPClassifier\n",
    "from sklearn.preprocessing import minmax_scale\n",
    "from sklearn.svm import SVC\n",
    "\n",
    "# Nous ne voulons pas avoir ce type d'avertissement, qui\n",
    "# n'est pas utile dans le cadre de ce devoir\n",
    "from sklearn.exceptions import ConvergenceWarning\n",
    "warnings.filterwarnings(\"ignore\", category=ConvergenceWarning)\n",
    "\n",
    "\n",
    "# Fonctions utilitaires liÃ©es Ã  l'Ã©valuation\n",
    "_times = []\n",
    "def checkTime(maxduration, question):\n",
    "    duration = _times[-1] - _times[-2]\n",
    "    if duration > maxduration:\n",
    "        print(\"[ATTENTION] Votre code pour la question {0} met trop de temps Ã  s'exÃ©cuter! \".format(question)+\n",
    "            \"Le temps maximum permis est de {0:.4f} secondes, mais votre code a requis {1:.4f} secondes! \".format(maxduration,duration)+\n",
    "            \"Assurez-vous que vous ne faites pas d'appels bloquants (par exemple Ã  show()) dans cette boucle!\") \n",
    "\n",
    "# DÃ©finition des durÃ©es d'exÃ©cution maximales pour chaque sous-question\n",
    "TMAX_KNN = 40\n",
    "TMAX_SVM = 200\n",
    "TMAX_PERCEPTRON = 400\n",
    "TMAX_EVAL = 80\n",
    "\n",
    "def fetchPendigits():\n",
    "    \"\"\"\n",
    "    Cette fonction tÃ©lÃ©charge le jeu de donnÃ©es pendigits et le\n",
    "    retourne sous forme de deux tableaux numpy. Le premier Ã©lÃ©ment\n",
    "    retournÃ© par cette fonction est un tableau de 10992x16 qui\n",
    "    contient les samples; le second Ã©lÃ©ment est un vecteur de 10992\n",
    "    qui contient les valeurs cible (target).\n",
    "    \"\"\"\n",
    "    host = 'vision.gel.ulaval.ca'\n",
    "    url = '/~cgagne/enseignement/apprentissage/A2018/travaux/ucipendigits.npy'\n",
    "    connection = HTTPConnection(host, port=80, timeout=10)\n",
    "    connection.request('GET', url)\n",
    "\n",
    "    rep = connection.getresponse()\n",
    "    if rep.status != 200:\n",
    "        print(\"ERREUR : impossible de tÃ©lÃ©charger le jeu de donnÃ©es UCI Pendigits! Code d'erreur {}\".format(rep.status))\n",
    "        print(\"VÃ©rifiez que votre ordinateur est bien connectÃ© Ã  Internet.\")\n",
    "        return\n",
    "    stream = BytesIO(rep.read())\n",
    "    dataPendigits = numpy.load(stream)\n",
    "    return dataPendigits[:, :-1].astype('float32'), dataPendigits[:, -1]\n",
    "\n",
    "# Ne modifiez rien avant cette ligne!\n",
    "\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Question 2B\n",
    "\n",
    "    # TODO Q2B\n",
    "    # Chargez le jeu de donnÃ©es Pendigits. Utilisez pour cela la fonction\n",
    "    # fetchPendigits fournie. N'oubliez pas de normaliser\n",
    "    # les donnÃ©es d'entrÃ©e entre 0 et 1 pour toutes les dimensions.\n",
    "    # Notez finalement que fetch_openml retourne les donnÃ©es d'une maniÃ¨re\n",
    "    # diffÃ©rente des fonctions load_*, assurez-vous que vous utilisez\n",
    "    # correctement les donnÃ©es et qu'elles sont du bon type.\n",
    "   \n",
    "    \n",
    "    # TODO Q2B\n",
    "    # SÃ©parez le jeu de donnÃ©es Pendigits en deux sous-jeux: entraÃ®nement (5000) et\n",
    "    # test (reste des donnÃ©es). Pour la suite du code, rappelez-vous que vous ne\n",
    "    # pouvez PAS vous servir du jeu de test pour dÃ©terminer la configuration\n",
    "    # d'hyper-paramÃ¨tres la plus performante. Ce jeu de test ne doit Ãªtre utilisÃ©\n",
    "    # qu'Ã  la toute fin, pour rapporter les rÃ©sultats finaux en gÃ©nÃ©ralisation.\n",
    "\n",
    "\n",
    "    # TODO Q2B\n",
    "    # Pour chaque classifieur :\n",
    "    # - k plus proches voisins,\n",
    "    # - SVM Ã  noyau gaussien,\n",
    "    # - Perceptron multicouche,\n",
    "    # dÃ©terminez les valeurs optimales des hyper-paramÃ¨tres Ã  utiliser.\n",
    "    # Suivez les instructions de l'Ã©noncÃ© quant au nombre d'hyper-paramÃ¨tres Ã \n",
    "    # optimiser et n'oubliez pas d'expliquer vos choix d'hyper-paramÃ¨tres\n",
    "    # dans votre rapport.\n",
    "    # Vous Ãªtes libres d'utiliser la mÃ©thodologie que vous souhaitez, en autant\n",
    "    # que vous ne touchez pas au jeu de test.\n",
    "    #\n",
    "    # Note : optimisez les hyper-paramÃ¨tres des diffÃ©rentes mÃ©thodes dans\n",
    "    # l'ordre dans lequel ils sont Ã©numÃ©rÃ©s plus haut, en insÃ©rant votre code\n",
    "    # d'optimisation entre les commentaires le spÃ©cifiant\n",
    "    \n",
    "\n",
    "    \n",
    "    _times.append(time.time())\n",
    "    # TODO Q2B\n",
    "    # Optimisez ici la paramÃ©trisation du kPP\n",
    "   \n",
    "\n",
    "    \n",
    "    _times.append(time.time())\n",
    "    checkTime(TMAX_KNN, \"K plus proches voisins\")\n",
    "    # TODO Q2B\n",
    "    # Optimisez ici la paramÃ©trisation du SVM Ã  noyau gaussien\n",
    "   \n",
    "\n",
    "\n",
    "    _times.append(time.time())\n",
    "    checkTime(TMAX_SVM, \"SVM\")\n",
    "    # TODO Q2B\n",
    "    # Optimisez ici la paramÃ©trisation du perceptron multicouche\n",
    "    # Note : il se peut que vous obteniez ici des \"ConvergenceWarning\"\n",
    "    # Ne vous en souciez pas et laissez le paramÃ¨tre max_iter Ã  sa\n",
    "    # valeur suggÃ©rÃ©e dans l'Ã©noncÃ© (100)\n",
    "    \n",
    "\n",
    "\n",
    "\n",
    "    _times.append(time.time())\n",
    "    checkTime(TMAX_PERCEPTRON, \"SVM\")\n",
    "    \n",
    "\n",
    "    # TODO Q2B\n",
    "    # Ã‰valuez les performances des meilleures paramÃ©trisations sur le jeu de test\n",
    "    # et rapportez ces performances dans le rapport\n",
    "    \n",
    "    \n",
    "\n",
    "    _times.append(time.time())\n",
    "    checkTime(TMAX_EVAL, \"Evaluation des modÃ¨les\")\n",
    "# N'Ã©crivez pas de code Ã  partir de cet endroit\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
